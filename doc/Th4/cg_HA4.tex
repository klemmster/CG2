\documentclass[a4paper,oneside,12pt]{scrartcl}

\usepackage[latin1]{inputenc}
\usepackage{amsmath,amssymb,graphicx,latexsym,stmaryrd,dsfont,amsthm}
\usepackage[T1]{fontenc}
\usepackage{ngerman,url,booktabs,scrpage2}
\usepackage{color}
\usepackage{algpseudocode}

\newcommand{\heading}[1]{\item{\textbf{#1}}$ $\\}
\newcommand{\formel}[1]{\begin{center}#1\end{center}}
\newcommand{\eqs}[1]{
$\begin{array}{rcll}
$ #1 $
\end{array}$}
\newcommand{\image}[2]{
\begin{center}
\includegraphics[scale = #1]{#2}
\end{center}
}

\newcounter{counter}
\stepcounter{counter}

\definecolor{gray}{gray}{.5}
\newcommand{\comment}[1]{\textcolor{gray}{\textit{// #1}}}
\newcommand{\task}[1]{
\section*{Aufgabe #1}
\stepcounter{counter}
}
\newcommand{\subtask}[1]{\subsection*{#1}}
\newcommand{\subsubtask}[1]{#1$ $\\}
\newcommand{\mathsum}[3]{\underset{#1}{\overset{#2}{\sum}}#3}
\newcommand{\isum}[1]{\mathsum{i=0}{n}{#1}}

\newcommand{\tab}{\noindent\hspace*{1cm}}
\newcommand{\twovector}[2]{\left(\begin{array}{c} #1 \\ #2 \end{array}\right)}
\newcommand{\threevector}[3]{\left(\begin{array}{c} #1 \\ #2 \\ #3 \end{array}\right)}
\newcommand{\fourmatrix}[4]{\left(\begin{array}{cc} #1 & #2 \\ #3 & #4 \end{array}\right)}
\newcommand{\ninematrix}[9]{\left(\begin{array}{ccc} #1 & #2 & #3 \\ #4 & #5 & #6 \\ #7 & #8 & #9 \end{array}\right)}
\newcommand{\nvector}[2]{\left(\begin{array}{c} #1 \\ \vdots \\ #2 \end{array}\right)}
\newcommand{\nmatrix}[4]{\left(\begin{array}{ccc} #1 & \ldots & #2 \\ \vdots & \ddots & \vdots \\ #3 & \ldots & #4 \end{array}\right)}
\newcommand{\eq}{&=&}
\newcommand{\eqbreak}{\\[0.5cm]}
\newcommand{\eqsmbreak}{\\[0.35cm]}
\newcommand{\eqtbreak}{\\[0.12cm]}
\newcommand{\eqbreakp}{\\[0.8cm]}
\newcommand{\eqsmbreakp}{\\[0.65cm]}
\newcommand{\eqtbreakp}{\\[0.32cm]}
\newcommand{\rc}{r^c}
\newcommand{\vvec}{\vec v}
\newcommand{\pnt}[1]{\textbf{#1}}
\newcommand{\ppnt}{\pnt{p}}

\parindent 0pt

\begin{document}

\begin{center}
\normalsize Computer Graphics 2\\[0.3cm]
\huge \textbf{Hausaufgabe 4} \normalsize\\[0.8cm]
\begin{tabular}{rl}
\texttt{343635} & Richard Klemm\\
\texttt{319716} & Andreas Fender\\
\texttt{315744} & Christopher Sierigk\\
\end{tabular}
\end{center}

\stepcounter{counter}

\task{1}

Ein Polyeder ist ein Polygonnetz, dass geschlossen ist. Diese Eigenschaft ist wichtig, da an jedem Punkt klar definiert sein muss, ob dieser innerhalb oder außerhalb der Fläche ist.

\task{2}


\task{3}

\textbf{a) Kante teilen}\\

\image{0.34}{res/edgeSplit.png}

\textbf{b) Kante entfernen}\\

In der Abbildung sind einige unwichtige Half Edges als eine Linie zusammengefasst:
\image{0.36}{res/edgeCollapse.png}

\task{4}

Eine Funktion welche die Approximationsqualität abschätzt, könnte für die baryzentrischen Koordinaten der anliegenden Dreiecke die Funktionswerte ermitteln. Der betragsmäßig größte Funktionswert ist dann ein Maß für die Approximationsqualität. Umso weiter sich dieser Wert von 0 unterscheidet, desto schlechter ist die Approximation.\\
\\
Die folgende Formel betrachtet lokal den Ring um einen Vertex und berechnet aus jedem Dreieck $(v_1,v_2,v_3)$ den maximalen Funktionswert der impliziten Funktion $f$ innerhalb der baryzentrischen Koordinaten. Aus den berechneten Maximalwerten jedes Dreiecks wird schließlich das Maximum berechnet:
\begin{quote}
$
%max \{ \Vert f(w_1\cdot v_1 + \ldots + w_n\cdot v_n)\Vert $ $|$ $ w_1 + \ldots + w_n = 1 \}
sup\{\\
$\tab$ sup\{ \Vert f(w_1\cdot v_1 + w_2\cdot v_2 + w_3\cdot v_3)\Vert $ $|$ $ w_1,w_2,w_3 \in [0,1], w_1 + w_2 + w_3 = 1 \}\\
|$ $F=(v_1,v_2,v_3) \in incidentFaces \}
$
\end{quote}


\task{5}

Dreiecksgitter können Sechseckgitter enthalten. Aus einem Seckseckgitter lässt sich immer ein Dreiecksgitter gewinnen, indem z.B. für jedes Sechseck ein Vertex im Zentrum eingefügt wird und Edges zu allen Vertices des Sechsecks erstellt werden:

\image{0.26}{res/hexTri.png}

Das entstandene Dreiecksgitter kann nun verfeinert werden, indem im Mittelpunkt jedes Dreiecks ein Vertex eingefügt und dieser mit den jeweiligen Dreiecksvertices verbunden wird. Das entstehende feinere Dreiecksnetz enthält auch eine verfeinerte Version des Ausgangssechsecknetzes:

\image{0.26}{res/hexRefine.png}

Die ausgegrauten Vertices und Edges müssen demnach entfernt werden.\\
Die folgende Abbildung zeigt, dass die entstandene Verfeinerung wiederholend ist:

\image{0.26}{res/hexPatch.png}


\end{document}
